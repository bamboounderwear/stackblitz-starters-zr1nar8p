<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Creative Domain Generator</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      text-align: center;
      margin: 50px auto;
      max-width: 700px;
    }
    input, select, button {
      padding: 8px;
      margin: 5px;
      font-size: 16px;
    }
    #results {
      margin-top: 30px;
    }
    .word-block {
      margin: 10px 0;
      font-size: 20px;
    }
    .word {
      font-weight: bold;
      margin-right: 10px;
    }
    .status {
      display: inline-block;
      margin-left: 10px;
      font-size: 14px;
    }
  </style>
</head>
<body>

  <h1>Creative Domain Generator</h1>

  <div>
    <label>Min Length:
      <input type="number" id="minLength" value="4" min="1">
    </label>
    <label>Max Length:
      <input type="number" id="maxLength" value="8" min="1">
    </label>
    <label>Words to Generate:
      <input type="number" id="wordCount" value="10" min="1" max="50">
    </label>
    <label>Creativity:
      <select id="creativity">
        <option value="1">üî• Wild (n=1)</option>
        <option value="2">üé® Medium (n=2)</option>
        <option value="3" selected>üß† Balanced (n=3)</option>
        <option value="4">üõ°Ô∏è Conservative (n=4)</option>
      </select>
    </label>
    <br>
    <button onclick="generateWords()">üîÅ Generate</button>
  </div>

  <div id="results"></div>

  <script>
    let markovChain = {};
    let seedWords = [];

    const suffixes = ["ly", "ify", "gen", "io", "zone", "ster", "lab", "hub"];

    async function loadWords() {
      try {
        const response = await fetch('words.txt');
        const text = await response.text();
        seedWords = text.split(/\r?\n/).map(w => w.trim().toLowerCase()).filter(Boolean);
      } catch (err) {
        document.getElementById("results").textContent = "‚ö†Ô∏è Failed to load words.txt";
        console.error("Error loading words.txt:", err);
      }
    }

    function buildMarkovChain(words, n = 3) {
      markovChain = {};
      for (const word of words) {
        const padded = "^".repeat(n - 1) + word + "$";
        for (let i = 0; i <= padded.length - n; i++) {
          const prefix = padded.slice(i, i + n - 1);
          const nextChar = padded[i + n - 1];
          if (!markovChain[prefix]) markovChain[prefix] = [];
          markovChain[prefix].push(nextChar);
        }
      }
    }

    function weightedPick(arr) {
      if (arr.length === 1) return arr[0];
      return Math.random() < 0.8
        ? arr[Math.floor(Math.random() * Math.min(2, arr.length))] // Top 2 bias
        : arr[Math.floor(Math.random() * arr.length)];
    }

    function isPronounceable(word) {
      const badPatterns = [
        /[^aeiou]{4,}/,  // 4+ consonants
        /[aeiou]{3,}/,   // 3+ vowels
        /[qxz]{2,}/,     // rare consonant runs
        /^.{0,2}$/       // too short
      ];
      return !badPatterns.some(p => p.test(word));
    }

    function generateWord(minLength = 4, maxLength = 8, n = 3) {
      let attempts = 0;
      while (attempts < 100) {
        const actualN = Math.random() < 0.3 ? Math.max(2, n - 1) : n;
        buildMarkovChain(seedWords, actualN);

        let current = "^".repeat(actualN - 1);
        let result = "";

        while (result.length < maxLength) {
          const possibilities = markovChain[current];
          if (!possibilities) break;
          const next = weightedPick(possibilities);
          if (next === "$") break;
          result += next;
          current = current.slice(1) + next;
        }

        if (result.length >= minLength && result.length <= maxLength && isPronounceable(result)) {
          // Occasionally append suffix
          if (Math.random() < 0.3) {
            result += suffixes[Math.floor(Math.random() * suffixes.length)];
          }
          return result;
        }

        attempts++;
      }
      return null;
    }

    function generateWords() {
      const minLength = parseInt(document.getElementById("minLength").value) || 4;
      const maxLength = parseInt(document.getElementById("maxLength").value) || 8;
      const count = Math.min(parseInt(document.getElementById("wordCount").value) || 10, 50);
      const n = parseInt(document.getElementById("creativity").value) || 3;

      const resultsDiv = document.getElementById("results");
      resultsDiv.innerHTML = "";

      for (let i = 0; i < count; i++) {
        const word = generateWord(minLength, maxLength, n);
        if (!word) continue;

        const block = document.createElement("div");
        block.className = "word-block";

        const span = document.createElement("span");
        span.className = "word";
        span.textContent = word;

        const button = document.createElement("button");
        button.textContent = "Check .com";
        button.onclick = () => checkAvailability(word, block);

        const status = document.createElement("span");
        status.className = "status";
        status.textContent = "";

        block.appendChild(span);
        block.appendChild(button);
        block.appendChild(status);
        resultsDiv.appendChild(block);
      }
    }

    async function checkAvailability(word, container) {
      const domain = word + ".com";
      const url = `https://domainr.p.rapidapi.com/v2/status?domain=${domain}`;

      const options = {
        method: 'GET',
        headers: {
          'X-RapidAPI-Key': '81cc7ecc64msh9b91aa89fbf36e5p19d919jsn3f1034a603a8',  // Replace with your actual key
          'X-RapidAPI-Host': 'domainr.p.rapidapi.com'
        }
      };

      const statusSpan = container.querySelector('.status');
      statusSpan.textContent = "Checking...";

      try {
        const response = await fetch(url, options);
        if (!response.ok) throw new Error(`API error: ${response.status}`);
        const result = await response.json();

        if (!result.status || !result.status[0]) throw new Error("Unexpected response format.");

        const status = result.status[0].status;

        if (status.includes("inactive")) {
          statusSpan.textContent = `‚úÖ Available`;
          statusSpan.style.color = "green";
        } else {
          statusSpan.textContent = `‚ùå Taken`;
          statusSpan.style.color = "red";
        }

      } catch (err) {
        console.error("API Error:", err);
        statusSpan.textContent = "‚ö†Ô∏è Error";
        statusSpan.style.color = "orange";
      }
    }

    loadWords(); // Load seed file on load
  </script>

</body>
</html>
